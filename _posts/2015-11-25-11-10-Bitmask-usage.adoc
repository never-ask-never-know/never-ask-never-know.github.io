= 1+1 = 10. Bitmask usage
:hp-image: cover_lines.jpg
:hp-tags: bitmask

Цікаво, наскільки розповсюджене зараз, в час "панування" високорівневих мов програмування та великих об"ємів пам"яті, використання побітових операцій (bitwise) та бітових масок (bitmask)? Мені чомусь здавалось, що двійкова система счислення може бути корисною для тих, хто займається низько-рівневим програмуванням (ніколи не зустрічала таких людей, але сподіваюсь, що вони існують), ну або для написання якогось хитрого ресурсозберігаючого алгоритму (людей, що займаються такими речами для роботи, а не для хобі, я теж, нажаль, не зустрічала). Яким же було моє здивування, коли на одному проекті я побачила в коді операцію на зразок наступної: +

	if (Request.PermissionMask & (8) > 0)
		{...}

Невже! Невже шкільні знання з двійкової системи счислення стануть в нагоді для роботи! Як виявиться пізніше, на двох моїх минулих звичайнісіньких корпоративних проектах використовувались бітові маски. Одним з них була програма написана років так 15 назад (ну тут можна зрозуміти, може на час написання не було інших варіантів просто і там ніхто не думав про те, що код має бути зрозумілим і self-descriptive), але інший проект був відносно новим. Ні в тому, ні в іншому випадку проблеми економії пам"яті та проблеми обробки великих об"ємів даних не було. 

== Bitmask

Спробую пояснити своє здивування. Спочатку розповім, що таке бітова маска. Bitmask - це спосіб представити характеристики об"єкту за допомогою цифр 0 та 1 (ну, тому що це *бітова* маска). Можна думати про бітову маску як про шифр: +

- Кожна цифра в числі відповідає за заздалегідь визначену властивість; 
- 0 може значити, наприклад, що певна властивість в об"єкті відсутня, а 1 - що присутня.

Для кращого розуміння, створимо бітові маски для кольорів. Є три базових кольори - червоний, жовтий та синій. Змішуючи ці кольори ми можемо отримати всі інші (я тут маю на увазі базові кольори для художників, живих людей, а не представлення кольору в комп"ютерах). 

|===
|Червоний|Жовтий|Синій| 
|0|0|1| Синій
|0|1|0| Жовтий
|1|0|0| Червоний
|0|1|1| Зелений
|1|1|0| Помаранчевий
|1|0|1| Фіолетовий
|===


Отримали такі двійкові коди: +

	1 - синій
    10 - жовтий
    100 - червоний
    11 - зелений
    110 - помаранчевий
    101 - фіолетовий

Зазвичай, якщо вирішують користуватись бітовими масками, то такі двійкові коди переводять в звичну для нас десяткову систему счислення:


|===
||2|1|0|
|синій|0|0|1|1 * 2^0^ = 1
|жовтий|0|1|0| 1 * 2^1^ = 2
|червоний|1|0|0| 1 * 2^2^ = 4
|зелений|0|1|1| 1 * 2^0^ + 1 * 2^1^ = 3
|помаранчевий|1|1|0| 1 * 2^1^ + 1 * 2^2^ = 6
|фіолетовий|1|0|1| 1 * 2^0^ + 1 * 2^2^ = 5
|===

Тепер, коди до наших кольорів виглядають так:

	1 - синій
    2 - жовтий
    4 - червоний
    3 - зелений
    6 - помаранчевий
    5 - фіолетовий

Якщо проаналізувати, то побачимо, що всі базові кольори є степенями 2, всі інші кольори, що ми отримали в результаті змішування є сумою відповідних базових кольорів, так фіолетовий = синій + червоний: +

	5 = 1 + 4 

Окрім цих властивостей, ще в програмах, такі "зашифровані" об"єкти розшифровуються бітовими операціями (bitwise), в основному операндом & (AND). Так, наприклад, якщо нам потрібно вибрати серед всієї множини наших кольорів тільки ті кольори, де був застосований синій колір, то ми виконаємо таку операцію:

	color = {1, 2, 4, 3, 6, 5} - наша множина всіх кольорів
	color & 1 > 0  = {1, 3, 5} - множина кольорів, в яких є синій колір (синій, зелений, фіолетовий)
    
Опишу детальніше, як ми це отримали:

Ми застосовуємо логічне AND до кожної пари бітів, які стоять на однакових позиціях у двійкових представленнях кольорів. Якщо обидва відповідних біта рівні 1, результуючий двійковий розряд дорівнює 1 (true), якщо ж хоча б один біт з пари дорівнює 0, результуючий двійковий розряд дорівнює 0 (false).

|=== 
|0|0|#1#| Синій
|0|1|0| Жовтий
|1|0|0| Червоний
|0|1|#1#| Зелений
|1|1|0| Помаранчевий
|1|0|#1#| Фіолетовий
|===
***
|===
|0|0|#1#| Синій
|===
***
|=== 
|0|0|*1*| Синій
|[line-through]*0*|[line-through]*0*|[line-through]*0*| [line-through]*Жовтий*
|[line-through]*0*|[line-through]*0*|[line-through]*0*| [line-through]*Червоний*
|0|0|*1*| Зелений
|[line-through]*0*|[line-through]*0*|[line-through]*0*| [line-through]*Помаранчевий*
|0|0|*1*| Фіолетовий
|===

Результат операції AND для жовтого, червоного та помаранчевого кольорів однаковий - 000, а значить вони не ввійшли в результуючий набір.


== Conclusion

Як бачите, застосування бітових масок є цікавим та дає вам можливість застосувати давно припорошені пилом знання з двійкової системи счислення. Крім того ви зможете в одному числі зберігати багато інформації - по одному біту на характеристику об"єкта, а це 8 * 4 = 32 характеристики в INT полі в .NET. Але, незважаючи на ці плюси, bitmask не  робить програму легкою для розуміння та подальшої підтримки, особливо, якщо розробник не задокументував свій шифр, або з часом він загубився чи став невалідним, в силу того, що інформація про нові параметри просто не оновлювалась.
У випадках, з якими я працювала більше підходило застосування звичайних бітових property під кожну властивість об"єкту замість бітової маски. В одному випадку, на базі цього "шифру" визначалось, яким способом рахувати ризики фінансового продукту (5 різновидів), в іншому випадку - визначався рівень доступу до певних даних (скільки точно не пам"ятаю, але точно навіть і близько не 32).

На сьогодні все, а в наступному пості я розповім про те, як можна удосконалити рішення, якщо ви, все ж таки, вирішили скористатись bitmask у своєму проекті.

icon:heart-o[size=2x]